<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>

<meta name="googlebot" content="index,follow,snippet,archive"/>
<meta name="robots" content="all,follow">
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="author" content=""/>

<meta name="generator" content="Hugo 0.80.0" />
    <title> Algorithms - Graphs |  Tori Writes (Online)</title>
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  
  
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ’¾</text></svg>">

  <link href="https://cdn.jsdelivr.net/npm/victormono@latest/dist/index.min.css" rel="stylesheet" onload="this.media='all';this.onload=null;">
<link href="https://fonts.googleapis.com/css2?family=Fira+Sans+Condensed:wght@400;700;900&display=swap" rel="stylesheet" onload="this.media='all';this.onload=null;">
<script src="https://kit.fontawesome.com/1902dd0653.js" crossorigin="anonymous"></script>
<noscript>
  <link href="https://cdn.jsdelivr.net/npm/victormono@latest/dist/index.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Sans+Condensed:wght@400;700;900&display=swap" rel="stylesheet">
</noscript>

  
  <link rel="stylesheet" href="/css/vendors/98.css">



<link href="/css/main.css" rel="stylesheet" defer/>


<style>
  @charset "UTF-8";@keyframes flicker{0%{opacity:1}10%{opacity:.4}20%{opacity:1}}@keyframes flicker-all{0%{opacity:1}3%{opacity:.8}6%{opacity:1}7%{opacity:1}8%{opacity:.6}9%{opacity:1}10%{opacity:1}99%{opacity:.8;text-shadow:none}100%{opacity:1}}*,*::before,*::after{margin:0;padding:0}html,body{font-family:victor mono,monospace;font-size:16px;font-weight:400}*,*::before,*::after{box-sizing:border-box}html,body{height:100%;width:100%}body{background-color:teal}main.page{background-image:linear-gradient(to bottom,rgba(226,227,233,0.4),rgba(226,227,233,0.4)),url("/images/clouds.png");background-repeat:no-repeat;background-size:cover;height:100%;overflow:auto;padding:1rem;width:100%}body a{text-decoration:none}nav{position:absolute}nav ul{list-style:none}
</style>




</head>
    <body>
      
  <main class="page">
    <div class="title">
      <h1>Algorithms - Graphs</h1>
      <div class="line"></div>
    </div>
    
      <h2 id="undirected-graphs">Undirected Graphs</h2>
<h3 id="some-problems">Some problems</h3>
<ul>
<li>Path</li>
<li>Shortest path</li>
<li>Cycle</li>
<li>Ehler tour: A cycle that uses each edge excatly once.</li>
<li>Hamilton tour: A cycle that uses each vertex exactly once
<ul>
<li>classical NP-complete problem.</li>
</ul>
</li>
<li>Connectivity</li>
<li>MST:</li>
<li>Biconnectivity: A vertex whose removal disconnects the graph</li>
<li>Planarity</li>
<li>Graph isomorphism: Are two graphs identical?
<ul>
<li>No one knows so far. A lonstanding open problem</li>
</ul>
</li>
</ul>
<h3 id="representations">Representations</h3>
<p>Real-world graphs tend to be <strong>sparse</strong> (huge number of vertices, small average vertex degree).</p>
<ul>
<li>Set-of-edges representation
<ul>
<li>unefficient</li>
</ul>
</li>
<li>Adjacency-matrix representation
<ul>
<li>space cost is prohibitive</li>
</ul>
</li>
<li>Adjacency-list array representation
<ul>
<li>GOOD</li>
</ul>
</li>
</ul>
<h3 id="adjacency-list-data-structure">Adjacency-list Data structure</h3>
<ul>
<li>Space usage proportional to V + E</li>
<li>Constant time to add an edge</li>
<li>Time proportional to the degree of v to iterate through vertices adjacent to v</li>
</ul>
<h3 id="depth-first-search-dfs">Depth-first Search (DFS)</h3>
<p>Typical applications:</p>
<ul>
<li>Find all vertices connected to a given source vertex</li>
<li>Find a path between two vertices</li>
</ul>
<p>Algorithm:</p>
<ul>
<li>Use recursion (a function-call stack) or an explicit stack.</li>
<li>Mark each visited vertex (and keep track of edge taken to visit it)</li>
<li>Return (retrace steps) when no unvisited options</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DepthFirstPaths</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> blloean<span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> edgeTO<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DepthFirstPaths</span><span style="color:#f92672">(</span>Graph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>        dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> s<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>Graph Gm <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>v<span style="color:#f92672">])</span>
            <span style="color:#f92672">{</span>
                dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> w<span style="color:#f92672">)</span>
                edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Propositions:</p>
<ol>
<li>DFS marks all vertices connected to s in time proportional to the sum of their degrees.</li>
<li>After DFS, can find vertices connected to s in constant time and can find a path to s in time proportional to its length.</li>
</ol>
<h3 id="breadth-first-search-bfs">Breadth-first Search (BFS)</h3>
<p>Typical applications:</p>
<ul>
<li>shortest path</li>
</ul>
<p>Algorithm:</p>
<ul>
<li>Put s onto a queue, and mark s as visited</li>
<li>Take the next vertex v from the queue and mark it</li>
<li>Put onto the queue all unmarked vertices that are adjacent to v</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BreadthFirstPaths</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> edgeTo<span style="color:#f92672">;</span>
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bfs</span><span style="color:#f92672">(</span>Graph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> q <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Queue<span style="color:#f92672">&lt;&gt;();</span>
        q<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
        marked<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> ture<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>q<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span>
        <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span><span style="color:#a6e22e">dequeue</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w<span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span>
            <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span>
                <span style="color:#f92672">{</span>
                    q<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
                    marked<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                    edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Proposition:</p>
<ol>
<li>BFS computes shortest paths (fewest number of edges) from s to all other vertices in a graph in time proportional to E + V</li>
</ol>
<h3 id="applications-of-dfs">Applications of DFS</h3>
<h4 id="connected-components">Connected components</h4>
<p>The goal is to preprocess graph to answer queries of the form <em>is v connected to w?</em> in constant time.</p>
<p>The relation <em>is connected to</em> is an equivalence relation:</p>
<ul>
<li>Reflexive: v is connected to v</li>
<li>Symmetric: if v is connected to w, then w is connected to v</li>
<li>Transitive: if v connected to w and w connected to x, then v connected to x</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CC</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> id<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">CC</span><span style="color:#f92672">(</span>Graph G<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        id <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>v<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
                count<span style="color:#f92672">++;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>Graph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        id<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> count<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> w<span style="color:#f92672">)</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="cycle-detection">Cycle detection</h4>
<p>Problem: Is a given graph acylic?</p>
<p><strong>TODO</strong></p>
<h4 id="two-colorability">Two-colorability</h4>
<p>Problem: Is the graph bipartite?</p>
<p><strong>TODO</strong></p>
<h4 id="symbol-graphs">Symbol graphs</h4>
<p><strong>TODO</strong></p>
<h4 id="degrees-of-separation">Degrees of separation</h4>
<p><strong>TODO</strong></p>
<h2 id="directed-graphs">Directed Graphs</h2>
<blockquote>
<p>A directed graph (or digraph) is a set of vertices and a collection of directed edges. Each directed edge connects an ordered pair of vertices.</p>
</blockquote>
<ul>
<li><em>outdegree</em>: the number of edges going <strong>from</strong> it</li>
<li><em>indegree</em>: the number fo edges going <strong>into</strong> it</li>
<li><em>directed path</em>: a sequence of vertices in which there is a (directed) edge pointing from each vertex in the sequence to its successor in the sequence</li>
<li><em>directed cycle</em></li>
<li><em>simple cycle</em>: a cycle with no repeated edges or vertices</li>
</ul>
<h3 id="representations-1">Representations</h3>
<p>Again, use <a href="#Adjacency-list-Data-structure">adjacency-lists representation</a></p>
<ul>
<li>Based on iterating over vertices pointing from v</li>
<li>Real-world digraphs tend to be sparse</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Digraph</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> V<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Bag<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;[]</span> adj<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Digraph</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> V<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">V</span> <span style="color:#f92672">=</span> V<span style="color:#f92672">;</span>
        adj <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Bag<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;[])</span> <span style="color:#66d9ef">new</span> Bag<span style="color:#f92672">[</span>V<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> V<span style="color:#f92672">;</span> v<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            adj<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Bag<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;[];</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addEdge</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> w<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        adj<span style="color:#f92672">[</span>v<span style="color:#f92672">].</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> adj<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="digraph-search">Digraph search</h3>
<p>Reachabiliity problem: Find all vertices reachable from s along a directed path.</p>
<p>We can use <a href="#Depth-first-Search-(DFS)">the same dfs method as for undirected graphs</a>.</p>
<ul>
<li>Every undirected graph is a digraph with edges in both directions.</li>
<li>DFS is a digraph algorithm,</li>
</ul>
<p>Reachability applications:</p>
<ul>
<li>program control-flow analysis
<ul>
<li>Dead-code elimination</li>
<li>infinite-loop detection</li>
</ul>
</li>
<li>mark-sweep garbage collector</li>
</ul>
<p>Other DFS problems:</p>
<ul>
<li>Path findind</li>
<li>Topological sort</li>
<li>Directed cycle detection</li>
<li>&hellip;</li>
</ul>
<p>BFS problems:</p>
<ul>
<li>shortest path</li>
<li>multiple-source shortest paths</li>
<li>web crawler application</li>
</ul>
<h3 id="topological-sort">Topological Sort</h3>
<blockquote>
<p>Topological sort: Given a digraph, put the vertices in order such that all its directed edges point from a vertix earlier in the order to a vertex later in the order (or report impossible).</p>
</blockquote>
<p>A digraph has a topological order <strong>if and only if</strong> it is a <em>directed acyclic graph</em> (DAG).
Topological sort redraws DAG so all edges poitn upwards.</p>
<p>use <strong>DFS</strong> again. It can be proved that reverse postorder of a DAG is a topological order.
(check P578 for the definition of Preorder/Postorder)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DepthFirstOrder</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> reversePost<span style="color:#f92672">;</span>

    publiv <span style="color:#a6e22e">DepthFirstOrder</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        reversePost <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;();</span>
        marked <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>v<span style="color:#f92672">])</span> dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>Digrapg G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> w<span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span>
        reversePost<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="directed-cycle-detection">Directed cycle detection</h4>
<p>To find out if a given digraph is a DAG, we can try to find a directec cycle in the digraph.
Use DFS and a stack to track the cycle.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#75715e">// TODO
</span></code></pre></div><p>Some very typical applications of directed cycle detection and topological sort:
(A directed cycle means the problem is infeasible)</p>
<ul>
<li>job schedule</li>
<li>course scuedule</li>
<li>inheritance</li>
<li>spreadsheet
<ul>
<li>vertex: cell</li>
<li>edge: formula</li>
</ul>
</li>
<li>symbolic links</li>
</ul>
<h3 id="strong-components">Strong components</h3>
<p>Vertices v and w are <strong>strongly connected</strong> if there is both a directed path from v to w and a directed path from w to v.
Strong connectivity is an equvicalence relation.</p>
<h4 id="kosaraju-sharir-algorithm">Kosaraju-Sharir Algorithm</h4>
<p>Kosaraju-Sharir is easy to implement but difficutl to understand. It runs DFS twice:</p>
<ul>
<li>Given a digraph G, run DFS to compute the topological order of its reverse $G^R$</li>
<li>Run DFS on G in the order given by first DFS</li>
</ul>
<p>TODO: ADD Proof</p>
<p><a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/KosarajuSharirSCC.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/KosarajuSharirSCC.java.html</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#960050;background-color:#1e0010">```</span>Java
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">KosarajuSharirSCC</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>     <span style="color:#75715e">// marked[v] = has vertex v been visited?
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> id<span style="color:#f92672">;</span>             <span style="color:#75715e">// id[v] = id of strong component containing v
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>            <span style="color:#75715e">// number of strongly-connected components
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Computes the strong components of the digraph {@code G}.
</span><span style="color:#75715e">     * @param G the digraph
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">KosarajuSharirSCC</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#75715e">// compute reverse postorder of reverse graph
</span><span style="color:#75715e"></span>        DepthFirstOrder dfs <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DepthFirstOrder<span style="color:#f92672">(</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">reverse</span><span style="color:#f92672">());</span>

        <span style="color:#75715e">// run DFS on G, using reverse postorder to guide calculation
</span><span style="color:#75715e"></span>        marked <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        id <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">:</span> dfs<span style="color:#f92672">.</span><span style="color:#a6e22e">reversePost</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>v<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
                count<span style="color:#f92672">++;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// DFS on graph G
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> 
        marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        id<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> count<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> w<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><h2 id="minimum-spanning-trees">Minimum Spanning Trees</h2>
<p>An edge-weighted-graph is a graph where we associate weight or costs with each edge.
A spanning tree of an undirected edge-weighted graph G is a subgraph T that is both <strong>a tree (conneted and acyclic)</strong> and <strong>spanning (includes all of the vertices)</strong>.
Given an (connected) undirected edge-weighted graph G with V vertices and E edges, the MST of it must have <strong>V - 1</strong> edges.
If the graph is not connceted, we compute minimum spanning forest (MST of each component).</p>
<ul>
<li>A <em>cut</em> in a graph is a partition of its vertices into two (nonempty) sets</li>
<li>A <em>crossing edge</em> connects a vertex in one set with a vertex in the other.</li>
<li>Cut property: Given any cut, the crossing edge of min weight is in the MST.</li>
</ul>
<h3 id="edge-weight-graph-data-type">Edge-weight Graph Data Type</h3>
<p>Edge:
<a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/Edge.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/Edge.java.html</a></p>
<p>EdgeWeigthedGraph:
<a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html</a></p>
<h3 id="greedy-mst-algorithm"><strong>Greedy MST Algorithm:</strong></h3>
<ul>
<li>Start with all edges colored gray.</li>
<li>Find cut with no blacked crossing edges; color its min-weight edge black.</li>
<li>Repeat until V-1 edges are colored black.</li>
</ul>
<h3 id="implementations-1-kruskals-algorithm">Implementations 1: Kruskal&rsquo;s algorithm</h3>
<p>For edges in ascending order of weight:</p>
<ul>
<li>Add next edge to Tree unless doing so would create a cycle.</li>
</ul>
<p>To efficiently solve this problem, use union-find :</p>
<ol>
<li>use a priority queue to maintain all the edges in V</li>
<li>union-find data structure:
<ul>
<li>maintain a set for each connected component in T.</li>
<li>if v and w are in saome set, then adding v-&gt;w would create a cycle</li>
<li>to add v&gt;w to T, merge sets containing v and w.</li>
</ul>
</li>
</ol>
<p>TODO: Add code</p>
<h3 id="implementations-2-prims-algorithm">Implementations 2: Prim&rsquo;s algorithm</h3>
<ul>
<li>Start with vertex 0 and greedily grow tree T.</li>
<li>Add To T the min weight edge with exactly oue endpoint in T.</li>
<li>Reapeat unitl V - 1 edges.</li>
</ul>
<p>The key to solve this problem is how do we find the crossing edge of minimal weight efficiently.</p>
<p>A lazy solution (in time proportional to $ElogE$, fair enough):</p>
<ol>
<li>Maintain a PQ of edges with (at least) one endpoint in T
<ul>
<li>Key = edge, priority = weight</li>
</ul>
</li>
<li>Delete-min to determine next edge e = v-&gt;w to add to T</li>
<li>Disregard if both endpoints v and w are marked (both in T)</li>
<li>Otherwise, let w be the unmarked vertex (not in T)
<ul>
<li>add to PQ and edge incident to w (assuming other endpoint not in T)</li>
<li>add e to T and mark w</li>
</ul>
</li>
</ol>
<p>TODO: add code</p>
<p>A eager solution (in time proprotional to $ElogV$, better):</p>
<ol>
<li>Maintain a PQ of vertices connected by an edge to T, where priority of v = weight of shortedt edge connecting v to T</li>
<li>Delete min vertex v and add its associated edge e = v-&gt;w to T</li>
<li>Update PQ by considering all edges e = v-&gt;x incident to v
<ul>
<li>ignore if x is already in T</li>
<li>add x to PQ if not alread on it</li>
<li>decrease priority of x if v-&gt;x becomes shortest edge connecting x to T</li>
</ul>
</li>
</ol>
<p>This solution uses an <a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/IndexMinPQ.java.html">indexed priority queue</a> data structure.</p>
<p>TODO: add code</p>
<h2 id="shortest-paths">Shortest Paths</h2>
<p><strong>Some variants:</strong></p>
<ul>
<li>Which vertices?
<ul>
<li>Single source</li>
<li>Source-sink</li>
<li>All pairs</li>
</ul>
</li>
<li>Edge weights
<ul>
<li>Nonegative weights</li>
<li>Euclidean weights</li>
<li>Arbitrary weights</li>
</ul>
</li>
<li>Cycles?
<ul>
<li>No directed cycles</li>
<li>No negative cycles</li>
</ul>
</li>
</ul>
<h3 id="edge-weighted-digraph-data-strcuture">Edge-weighted digraph data strcuture</h3>
<p>Weighted directed edge:
<a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/DirectedEdge.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/DirectedEdge.java.html</a></p>
<p>Edge-weighted digraph:
<a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedDigraph.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedDigraph.java.html</a></p>
<p>Use adjacency-lists implementation same as <a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html">EdgeWeightedGraph</a></p>
<h3 id="generic-single-source-shortest-paths">Generic Single-source Shortest paths</h3>
<p>Our goal is to find the shortest path from s to every other vertex. As a result, what we find will be the <strong>shortest-paths tree (SPT)</strong> for source s.</p>
<h4 id="relax-edge-e--v-w">Relax edge e = v-&gt;w</h4>
<ul>
<li>distTo[v] is length of shortest known path from s to v</li>
<li>distTo[w] is length of shortest known path from s to w</li>
<li>esgeTo[w] is last edge on shortest known pathh from s to w</li>
<li>if e = v-&gt;w gives shorter path to w through v, update both distTo[w] and edgeTo[w]</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">relax</span><span style="color:#f92672">(</span>DirectedEdge e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">(),</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">to</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">();</span>
        edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="optimality-conditions">Optimality conditions</h4>
<p>Given an edge-weighted digraph G, distTo[] are the shortest path distances from s <strong>iff</strong>:</p>
<ul>
<li>distTo[s] = 0</li>
<li>For each vertex v, distTo[v] is the length of some path from s to v.</li>
<li>For each edge e = v-&gt;w, distTo[w] &lt;= distTo[v] + e.weight()</li>
</ul>
<h4 id="generic-algorithm">Generic algorithm</h4>
<pre><code>Generic algorithm (to compute SPT from s) {
    Initialize distTo[s] = 0 and distTo[v] = $\infty$

    Repeat until optimality conditions are satisfied:
        - Relax any edge
}
</code></pre><p>Efficient implementations:</p>
<ul>
<li>Nonnegative weights: <a href="#implement-1-dijkstras-algorithm">Dijkstra&rsquo;s algorithm</a></li>
<li>No directed cycles (DAGs): <a href="#implement-2-topological-sort-algorithm">Topological sort algorithm</a></li>
<li>No negative cycles: <a href="#implement-3-bellman-ford-algorithm">Bellman-Ford</a></li>
</ul>
<h3 id="implement-1-dijkstras-algorithm">Implement 1: Dijkstra&rsquo;s algorithm</h3>
<p>When there is no nonnegative weight exists, we can use Dijkstra&rsquo;s algorithm.</p>
<ul>
<li>Consider vertices in increasing order of distance from s (non-tree vertex with the lowest distTo[] value)</li>
<li>add vertex to tree and relax all edges pointing from that vertex</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DijkstraSP</span><span style="color:#f92672">{</span>
        <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DijkstraSP</span><span style="color:#f92672">(</span>EdgeWeightedDigraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        edgeTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DirectedEdge<span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        distTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        pq <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> IndexMinPQ<span style="color:#f92672">&lt;</span>Double<span style="color:#f92672">&gt;(</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">());</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Double<span style="color:#f92672">.</span><span style="color:#a6e22e">POSITIVE_INFINITY</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        distTo<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>

        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>s<span style="color:#f92672">,</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">while</span><span style="color:#f92672">(!</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> v<span style="color:#f92672">=</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">delMin</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                relax<span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">relax</span><span style="color:#f92672">(</span>DirectedEdge e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">(),</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">to</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">();</span>
            edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>w<span style="color:#f92672">))</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">decreaseKey</span><span style="color:#f92672">(</span>w<span style="color:#f92672">,</span> distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]);</span>
            <span style="color:#66d9ef">else</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>w<span style="color:#f92672">,</span> distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><strong>Compare to Prim&rsquo;s algorithm:</strong></p>
<ul>
<li>Both are computing a graph&rsquo;s spanning tree</li>
<li>Prim&rsquo;s algorithm choose closest vertex to tree as next vertex, while Dijkstra&rsquo;s algorithm choose closest vertex to the source</li>
</ul>
<h3 id="implement-2-topological-sort-algorithm">Implement 2: Topological sort algorithm</h3>
<p>When the graph is a DAG, we can consider vertices in topological order and do relaxing.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>    Topological topological <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Topological<span style="color:#f92672">(</span>G<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">:</span> topological<span style="color:#f92672">.</span><span style="color:#a6e22e">order</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            relax<span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p><strong><a href="https://en.wikipedia.org/wiki/Seam_carving">Seam carving</a></strong>: Resize an image without distortion.</p>
<p><strong>Longest paths</strong>:</p>
<ul>
<li>Formuate as a shortest paths problem in edge-weighted DAGs
<ul>
<li>Negate all weights</li>
<li>Find shortest paths</li>
<li>Negate weights in result</li>
</ul>
</li>
<li>Allpication: Parallel job scheduling (<a href="https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AA%E3%83%86%E3%82%A3%E3%82%AB%E3%83%AB%E3%83%91%E3%82%B9%E6%B3%95">Critical path method, CPM</a>).</li>
</ul>
<h3 id="implement-3-bellman-ford-algorithm">Implement 3: Bellman-Ford algorithm</h3>
<blockquote>
<p>A SPT exists iff no negative cycles (a directed cycle whose sum of edge weights is negative).</p>
</blockquote>
<p>When we want to find shortest paths with nagative weights, Dijkstra&rsquo;s algorithms doesn&rsquo;t work.
We can use Bellman-Ford algorithm as long as there is no negative cycle in the graph.
(Bellman-Ford algorithm is a dynamic programming algorithm)</p>
<ul>
<li>Initialize distTo[s] = 0 and distTo[v] = $\infty$</li>
<li>Maintain a queue and repeat until the queue is empty or find a cycle:
<ul>
<li>Pop vertex v from q</li>
<li>Relax each edge pointing from v to  any vertex w:
<ul>
<li>if distTo[w] can be de decreased, update distTo[w] and add w to the queue</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">BellmanFordSP</span><span style="color:#f92672">(</span>EdgeWeightedDigraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        distTo  <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        edgeTo  <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DirectedEdge<span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        onQueue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span>
            distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Double<span style="color:#f92672">.</span><span style="color:#a6e22e">POSITIVE_INFINITY</span><span style="color:#f92672">;</span>
        distTo<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">;</span>

        <span style="color:#75715e">// Bellman-Ford algorithm
</span><span style="color:#75715e"></span>        queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;();</span>
        queue<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
        onQueue<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>queue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>hasNegativeCycle<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">dequeue</span><span style="color:#f92672">();</span>
            onQueue<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            relax<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">relax</span><span style="color:#f92672">(</span>EdgeWeightedDigraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">to</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
                distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">();</span>
                edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>onQueue<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                    queue<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
                    onQueue<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(++</span>cost <span style="color:#f92672">%</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                findNegativeCycle<span style="color:#f92672">();</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>hasNegativeCycle<span style="color:#f92672">())</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>  <span style="color:#75715e">// found a negative cycle
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

</code></pre></div><p>Bellman-Ford algorithm can also be used for finding a negative cycle.</p>
<p>Negative cycle application: arbitrage detection.</p>

    
  </main>

      


    </body>
</html>
